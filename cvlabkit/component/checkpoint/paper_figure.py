"""Paper-quality figure generation for augmentation flow visualization."""

from pathlib import Path

import matplotlib
import matplotlib.pyplot as plt
import torch
from einops import rearrange
from torchvision.utils import make_grid, save_image

matplotlib.use("Agg")  # Non-interactive backend


class PaperFigure:
    """Generate publication-quality figures for augmentation flow."""

    def __init__(self, save_dir: str, dpi: int = 300):
        """Args:
        save_dir: Directory to save figures
        dpi: Dots per inch for saved figures
        """
        self.save_dir = Path(save_dir)
        self.save_dir.mkdir(parents=True, exist_ok=True)
        self.dpi = dpi

    def difficulty_progression(
        self,
        original_images: torch.Tensor,
        generated_images_by_difficulty: list,
        true_aug_images_by_difficulty: list,
        difficulties: list,
        filename: str = "difficulty_progression.png",
    ):
        """Figure 1: Show how augmentation strength changes with difficulty.

        Args:
            original_images: [B, C, H, W] original images
            generated_images_by_difficulty: List of [B, C, H, W], one per difficulty level
            true_aug_images_by_difficulty: List of [B, C, H, W], ground truth augmentations
            difficulties: List of difficulty values (e.g., [0.0, 0.25, 0.5, 0.75, 1.0])
            filename: Output filename
        """
        num_samples = original_images.shape[0]
        num_difficulties = len(difficulties)

        # Create grid: rows = [Original, Generated, True Aug], cols = difficulties
        rows = []

        # Row 1: Original (repeated)
        orig_row = torch.stack(
            [original_images] * num_difficulties, dim=1
        )  # [B, D, C, H, W]
        rows.append(rearrange(orig_row, "b d c h w -> (b d) c h w"))

        # Row 2: Generated by difficulty
        gen_row = torch.stack(generated_images_by_difficulty, dim=1)  # [B, D, C, H, W]
        rows.append(rearrange(gen_row, "b d c h w -> (b d) c h w"))

        # Row 3: True augmentation by difficulty
        true_row = torch.stack(true_aug_images_by_difficulty, dim=1)  # [B, D, C, H, W]
        rows.append(rearrange(true_row, "b d c h w -> (b d) c h w"))

        # Stack all rows
        all_images = torch.cat(rows, dim=0)  # [3*B*D, C, H, W]

        # Make grid
        grid = make_grid(
            all_images,
            nrow=num_samples * num_difficulties,
            normalize=True,
            padding=2,
            pad_value=1.0,
        )

        # Save
        save_path = self.save_dir / filename
        save_image(grid, save_path)

        # Add text labels using matplotlib
        self._add_labels(
            save_path,
            row_labels=["Original", "Flow-Generated", "True RandAugment"],
            col_labels=[f"d={d:.2f}" for d in difficulties],
            num_samples=num_samples,
        )

        return save_path

    def comparison_with_baseline(
        self,
        original: torch.Tensor,
        randaugment: torch.Tensor,
        flow_weak: torch.Tensor,
        flow_strong: torch.Tensor,
        confidences: torch.Tensor,
        filename: str = "method_comparison.png",
    ):
        """Figure 2: Compare flow-based vs traditional augmentation.

        Shows how flow adapts augmentation strength based on confidence,
        while RandAugment always applies same strength.

        Args:
            original: [B, C, H, W] original images
            randaugment: [B, C, H, W] RandAugment (fixed strength)
            flow_weak: [B, C, H, W] flow-generated for high confidence
            flow_strong: [B, C, H, W] flow-generated for low confidence
            confidences: [B] confidence scores
            filename: Output filename
        """
        # Sort by confidence
        sorted_idx = torch.argsort(confidences, descending=True)

        # Take top-k high confidence and bottom-k low confidence
        k = min(4, len(sorted_idx) // 2)
        high_conf_idx = sorted_idx[:k]
        low_conf_idx = sorted_idx[-k:]

        # Create comparison grid
        high_conf_images = torch.stack(
            [
                original[high_conf_idx],
                randaugment[high_conf_idx],
                flow_weak[high_conf_idx],
            ],
            dim=1,
        )  # [k, 3, C, H, W]

        low_conf_images = torch.stack(
            [
                original[low_conf_idx],
                randaugment[low_conf_idx],
                flow_strong[low_conf_idx],
            ],
            dim=1,
        )  # [k, 3, C, H, W]

        # Combine
        all_images = torch.cat(
            [
                rearrange(high_conf_images, "b views c h w -> (b views) c h w"),
                rearrange(low_conf_images, "b views c h w -> (b views) c h w"),
            ],
            dim=0,
        )

        grid = make_grid(all_images, nrow=3, normalize=True, padding=2, pad_value=1.0)

        save_path = self.save_dir / filename
        save_image(grid, save_path)

        self._add_labels(
            save_path,
            row_labels=[
                f"High Conf (>{confidences[high_conf_idx].mean():.2f})",
                f"Low Conf (<{confidences[low_conf_idx].mean():.2f})",
            ],
            col_labels=["Original", "RandAugment", "Flow-based"],
            num_samples=k,
        )

        return save_path

    def training_progression(
        self, samples_by_epoch: dict, filename: str = "training_progression.png"
    ):
        """Figure 3: Show quality improvement over training.

        Args:
            samples_by_epoch: Dict mapping epoch -> (original, generated) tensors
                Example: {0: (orig, gen), 50: (orig, gen), 200: (orig, gen)}
            filename: Output filename
        """
        epochs = sorted(samples_by_epoch.keys())

        rows = []
        for epoch in epochs:
            original, generated = samples_by_epoch[epoch]
            # Stack original and generated vertically
            pair = torch.stack([original, generated], dim=1)  # [B, 2, C, H, W]
            rows.append(rearrange(pair, "b views c h w -> (b views) c h w"))

        all_images = torch.cat(rows, dim=0)

        grid = make_grid(all_images, nrow=2, normalize=True, padding=2, pad_value=1.0)

        save_path = self.save_dir / filename
        save_image(grid, save_path)

        self._add_labels(
            save_path,
            row_labels=[f"Epoch {e}" for e in epochs],
            col_labels=["Original", "Generated"],
            num_samples=original.shape[0],
        )

        return save_path

    def _add_labels(
        self, image_path: Path, row_labels: list, col_labels: list, num_samples: int
    ):
        """Add text labels to saved image using matplotlib."""
        # Load saved image
        from PIL import Image

        img = Image.open(image_path)

        # Create figure with labels
        fig, ax = plt.subplots(figsize=(12, 8), dpi=self.dpi)
        ax.imshow(img)
        ax.axis("off")

        # Add row labels (left side)
        height = img.height
        for i, label in enumerate(row_labels):
            y_pos = (i + 0.5) * height / len(row_labels)
            ax.text(
                -10,
                y_pos,
                label,
                fontsize=10,
                ha="right",
                va="center",
                bbox=dict(boxstyle="round", facecolor="white", alpha=0.8),
            )

        # Add column labels (top)
        width = img.width
        for i, label in enumerate(col_labels):
            x_pos = (i + 0.5) * width / len(col_labels)
            ax.text(
                x_pos,
                -10,
                label,
                fontsize=10,
                ha="center",
                va="bottom",
                bbox=dict(boxstyle="round", facecolor="white", alpha=0.8),
            )

        # Save with labels
        labeled_path = (
            image_path.parent / f"{image_path.stem}_labeled{image_path.suffix}"
        )
        plt.tight_layout()
        plt.savefig(labeled_path, dpi=self.dpi, bbox_inches="tight")
        plt.close()

        return labeled_path
